<!doctype html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <style>
        html,body {
            padding: 0;
            margin: 0;
        }

        canvas {
            background-color:rgba(0,0,0,1);
            -webkit-transition: background-color 1s ease-in-out;
            -o-transition: background-color 1s ease-in-out;
            transition: background-color 1s ease-in-out;
        }
    </style>
    <title>canvas粒子特效</title>
</head>
<body>
<div>
    <canvas id='canvas' width="1200" height="800">浏览器不支持canvas</canvas>
</div>
<script>
// 粉红，绿色，天蓝色，白色，紫色
    (function(){
        var RequestAnimFrame=window.requestAnimationFrame 
            || window.webkitRequestAnimationFrame 
            || window.mozRequestAnimationFrame 
            || window.oRequestAnimationFrame 
            || window.msRequestAnimationFrame 
            || function(callback) {return window.setTimeout(callback, 16); };

        var CVS=(function(){
            var canvas=document.getElementById('canvas'),
                ctx=canvas.getContext('2d');
                vpx=canvas.width/2,
                vpy=canvas.height/2;

            canvas.width=window.innerWidth;
            canvas.height=window.innerHeight;
            vpx=canvas.width/2;
            vpy=canvas.height/2;
            ctx.translate(this.vpx,this.vpy);//坐标原点重置为中间

            return {
                canvas:canvas,
                ctx:ctx,
                vpx: vpx,
                vpy: vpy,
                clearRect:function(){
                    ctx.clearRect(-vpx, -vpy, canvas.width, canvas.height);
                }
            }
        }());

        function getRandom(a, b) {
            return Math.floor(Math.random() * (b - a)) + a
        }

        function PointEffect(opt){
            var options={
                zRadius:200,
                zPos:0,
                txts:['粒子特效']
            };
            for(var prop in opt){
                opt[prop]&&(options[prop]=opt[prop]);
            }

            this.zRadius=options.zRadius;//z轴的半径
            this.zPos=options.zPos;//控制距离
            this.txts=options.txts;
            this.angleX=Math.PI/3000,
            this.angleY=Math.PI/3000,
            this.poionts=[];
        }
        PointEffect.prototype={
            init:function(){
            	this.bindEvent();
                this.animate(0);
            },
            bindEvent:function(){
            	var self=this;
            	document.addEventListener('mousemove', function(event){
					var x = event.clientX - CVS.vpx;
					var y = event.clientY - CVS.vpy;
					self.angleY = x*0.00001;
					self.angleX = y*0.00001;
            	});
            },
            drawText:function(txt){
                CVS.ctx.save()
                CVS.ctx.font = "180px Microsoft YaHei bold";
                // 设置渐变
                var gradient=CVS.ctx.createLinearGradient(-CVS.vpx,0,CVS.vpx,0);
                gradient.addColorStop(0,'#0f0');
                gradient.addColorStop(0.3,'purple');
                gradient.addColorStop(0.5,'pink');
                gradient.addColorStop(0.6,'orange');
                gradient.addColorStop(1,'yellow');

                CVS.ctx.fillStyle=gradient;
                CVS.ctx.textAlign = "center";
                CVS.ctx.textBaseline = "middle";
                CVS.ctx.fillText(txt, 0,0);
                CVS.ctx.restore();
            },
            getImgData:function(txt){
                var imgData = CVS.ctx.getImageData(0,0, CVS.canvas.width, CVS.canvas.height);
                CVS.clearRect();
                this.points = [];
                for (var x = 0; x < imgData.width; x += 8) {
                    for (var y = 0; y < imgData.height; y += 8) {
                        var i = (y * imgData.width + x) * 4;
                        if (imgData.data[i] >= 20) {
                            this.points.push(new Point(this.zRadius,this.zPos,x, y, 0, 4,{r:imgData.data[i],g:imgData.data[i+1],b:imgData.data[i+2]}));
                        }
                    }
                }
            },
            // 绕x轴旋转
            rotateX:function (ball,angleX){
                var cos = Math.cos(angleX),
                    sin = Math.sin(angleX),
                    y1 = ball.y * cos - ball.z * sin,
                    z1 = ball.z * cos + ball.y * sin,
                    y2 = ball.dy * cos - ball.dz * sin,
                    z2 = ball.dz * cos + ball.dy * sin,
                    y3 = ball.fy * cos - ball.fz * sin,
                    z3 = ball.fz * cos + ball.fy * sin;
                ball.y = y1;
                ball.z = z1;
                ball.dy = y2;
                ball.dz = z2;
                ball.fy = y3;
                ball.fz = z3;
            },
            // 绕y轴旋转
            rotateY:function (ball, angleY) {
                var cos = Math.cos(angleY),
                    sin = Math.sin(angleY),
                    x1 = ball.x * cos - ball.z * sin,
                    z1 = ball.z * cos + ball.x * sin,
                    x2 = ball.dx * cos - ball.dz * sin,
                    z2 = ball.dz * cos + ball.dx * sin,
                    x3 = ball.fx * cos - ball.fz * sin,
                    z3 = ball.fz * cos + ball.fx * sin;
                ball.x =x1;
                ball.z =z1;
                ball.dx =x2;
                ball.dz =z2;
                ball.fx =x3;
                ball.fz =z3;
            },
            // 绕z轴旋转
            rotateZ:function(ball,angleZ){
                var cos = Math.cos(angleZ),
                    sin = Math.sin(angleZ),
                    x1 = ball.x * cos - ball.y * sin,
                    y1 = ball.y * cos + ball.x * sin;
                ball.x = x1;
                ball.y = y1;
            },
            animate:function(index){
                var isStop=true,
                    stage=0,
                    zoom=0.05,
                    startTime=new Date(), 
                    angleZ=index%2?Math.PI/300:-Math.PI/300,
                    self=this;

                this.drawText(this.txts[index]);
                this.getImgData(this.txts[index]);
                for(var i=0;i<150;i++){
                	var point=new Point(self.zRadius,self.zPos,0, 0, 10, 4,{r:getRandom(50,250),g:getRandom(50,250),b:getRandom(50,250)},true);
                	point.x=getRandom(-self.zRadius*2,self.zRadius*2);
                	point.y=getRandom(-self.zRadius*2,self.zRadius*2);
                	point.z=getRandom(-self.zRadius*3,self.zRadius*3);
                	self.points.unshift(point);
                }
                (function(){
                    isStop=true;
                    self.points.forEach(function(item,i){
                        switch(stage){
                        	case 0:
                        		if(item.isBg){
                        			self.rotateZ(item,angleZ);
                        			item.zPos+=3;//视角后退
                        		}
                                if(new Date()-startTime<2000){
                                    isStop=false;
                                }
                        		break;
                            case 1:
	                            self.rotateY(item,self.angleY);
	                        	self.rotateX(item,self.angleX);
                            	if(item.isBg){return true;}
                                if(Math.abs(item.x-item.dx)<0.1&&Math.abs(item.y-item.dy)<0.1&&Math.abs(item.z-item.dz)<0.1){
                                    item.x=item.dx;
                                    item.y=item.dy;
                                    item.z=item.dz;
                                } else {
                                    item.x=item.x+(item.dx-item.x)*zoom;
                                    item.y=item.y+(item.dy-item.y)*zoom;
                                    item.z=item.z+(item.dz-item.z)*zoom;
                                    isStop=false;
                                }
                                break;
                            case 2:
	                            self.rotateY(item,self.angleY);
	                            self.rotateX(item,self.angleX);
                            	if(item.isBg){return true;}
                                if(Math.abs(item.x-item.fx)<0.1&&Math.abs(item.y-item.fy)<0.1&&Math.abs(item.z-item.fz)<0.1){
                                    item.x=item.fx;
                                    item.y=item.fy;
                                    item.z=item.fz;
                                } else {
                                    item.x=item.x+(item.fx-item.x)*zoom;
                                    item.y=item.y+(item.fy-item.y)*zoom;
                                    item.z=item.z+(item.fz-item.z)*zoom;
                                    isStop=false;
                                }
                                break;
                            default:break;
                        }
                    });
                    self.points.sort(function(a,b){
                        return b.z-a.z;
                    });

                    CVS.clearRect();
                    self.points.forEach(function(item,i){
                    	if(stage==0&&!item.isBg){return true;}
                    	item.paint(); 
                    });

                    if(isStop&&stage==2){
                        CVS.clearRect();
                        self.animate(++index%self.txts.length);
                        return false;
                    }
                    if(isStop&&stage!=2){
                        stage++;
                    }
                    RequestAnimFrame(arguments.callee);
                }());
            },
        };

        function Point(zRadius,zPos,x,y,z,radius,rgb,isBg){
            // 点在字体中的坐标
            this.dx=x-CVS.vpx;
            this.dy=y-CVS.vpy;
            this.dz=z;
            // 点当前的坐标
            this.x=getRandom(-CVS.vpx,CVS.vpx);
            this.y=getRandom(-CVS.vpy,CVS.vpy);
            this.z=getRandom(-zRadius,zRadius);
            // 点最终飞离的坐标
            this.fx=getRandom(-CVS.vpx,CVS.vpx);
            this.fy=getRandom(-CVS.vpy,CVS.vpy);
            this.fz=getRandom(-zRadius,zRadius);
            this.radius=radius;
            this.rgb=rgb;
            this.zRadius=zRadius;
            this.zPos=zPos;
            this.isBg=isBg||false;
        }
        Point.prototype.paint=function(){
            var scale = Math.abs(this.zRadius/(this.zRadius-this.z+this.zPos));
            CVS.ctx.save();
            CVS.ctx.beginPath();
            CVS.ctx.arc(this.x*scale,this.y*scale, this.radius * scale, 0, 2 * Math.PI);
            CVS.ctx.fillStyle = 'rgba('+this.rgb.r+','+this.rgb.g+','+this.rgb.b+',' + scale*0.8 + ')';
            CVS.ctx.fill();
            CVS.ctx.restore();
        };

        var effect=new PointEffect({zPos:0,txts:['粒子特效','canvas','jeff.zhong','生日快乐']});
        effect.init();
    }());
</script>
</body>
</html>