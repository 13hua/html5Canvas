<!doctype html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <style>
        html,body {
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        canvas {
			background-color:rgba(0,0,0,0);
            -webkit-transition: background-color 1s ease-in-out;
            -o-transition: background-color 1s ease-in-out;
            transition: background-color 1s ease-in-out;
        }
    </style>
    <title>canvas粒子特效</title>
</head>
<body>
<div>
    <canvas id='canvas' width="1200" height="800">浏览器不支持canvas</canvas>
</div>
<script>
	(function(){
        var requestAnimFrame=window.requestAnimationFrame 
            || window.webkitRequestAnimationFrame 
            || window.mozRequestAnimationFrame 
            || window.oRequestAnimationFrame 
            || window.msRequestAnimationFrame 
            || function(callback) {return window.setTimeout(callback, 16); };

		var canvas=document.getElementById('canvas'),
			ctx=canvas.getContext('2d'),
            gradient=ctx.createLinearGradient(0,0,canvas.width,0),
			zRadius = 200,
			text='文字特效',
            points=[];
        var vpx = canvas.width/2;
            vpy = canvas.height/2;
		// function PointEffect(opt){
		// 	var options={
		// 		canvas:null,
		// 		zRadius:250,
		// 		text:'粒子特效'
		// 	};
		// 	for(var prop in opt){
		// 		opt[prop]&&(options[prop]=opt[prop]);
		// 	}
		// 	this.canvas=options.canvas;
		// 	this.ctx=this.canvas.getContext('2d');
		// 	this.zRadius=options.zRadius;
		// 	this.poionts=[];
		// }
		// PointEffect.prototype={
		// 	init:function(){

		// 	},
		// 	animate:function(){
				
		// 	}
		// };


		function getImgData(text) {
			drawText(text);
			var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			var points = [];
			for (var x = 0; x < imgData.width; x += 6) {
				for (var y = 0; y < imgData.height; y += 6) {
					var i = (y * imgData.width + x) * 4;
					if (imgData.data[i] >= 50) {
						var point = new Point(x, y, 0, 3,{r:imgData.data[i],g:imgData.data[i+1],b:imgData.data[i+2]});
						points.push(point);
					}
				}
			}
			return points;
		}

		function drawText(text) {
			ctx.save()
			ctx.font = "200px Microsoft YaHei bold";
            // 设置渐变
            gradient.addColorStop(0,'#00ff00');
            gradient.addColorStop(0.3,'purple');
            gradient.addColorStop(0.5,'red');
            gradient.addColorStop(0.6,'orange');
            gradient.addColorStop(1,'yellow');

            ctx.fillStyle=gradient;
            ctx.globalCompositeOperation='lighter';
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			ctx.fillText(text, canvas.width / 2, canvas.height / 2);
			ctx.restore();
		}

		function animate(){
            var isStop=true,
                stage=0,
                zoom=0.05,
                startTime=new Date();
            (function(){
                isStop=true;
                points.forEach(function(item,i){
                    switch(stage){
                        case 0:
                            if(Math.abs(item.x-item.dx)<0.1&&Math.abs(item.y-item.dy)<0.1&&Math.abs(item.z-item.dz)<0.1){
                                item.x=item.dx;
                                item.y=item.dy;
                                item.z=item.dz;
                            } else {
                                item.x=item.x+(item.dx-item.x)*zoom;
                                item.y=item.y+(item.dy-item.y)*zoom;
                                item.z=item.z+(item.dz-item.z)*zoom;
                                isStop=false;
                            }
                            break;
                        case 1:
                            if(Math.abs(item.x-item.fx)<0.1&&Math.abs(item.y-item.fy)<0.1&&Math.abs(item.z-item.fz)<0.1){
                                item.x=item.fx;
                                item.y=item.fy;
                                item.z=item.fz;
                            } else {
                                item.x=item.x+(item.fx-item.x)*zoom;
                                item.y=item.y+(item.fy-item.y)*zoom;
                                item.z=item.z+(item.fz-item.z)*zoom;
                                isStop=false;
                            }
                            break;
                        case 2:
                            rotateY(item,Math.PI/500);
                            if(new Date()-startTime<5000){
                                stop=false;
                            }
                            break;
                        default:break;
                    }
                });
                points.sort(function(a,b){
                    return b.z-a.z;
                });

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                points.forEach(function(item,i){item.paint(); });

                if(isStop&&stage==2){
                    return false;
                }
                if(isStop&&stage!=2){
                    stage++;
                    if(stage==1){
                        canvas.style.backgroundColor='rgba(0,0,0,0.9)';
                    }
                    if(stage==2){
                        startTime=new Date();
                    }
                }
                requestAnimFrame(arguments.callee);
            }());
		}

        // function rotateY(ball, angleY) {
        //     // 把角度三角函数化，以便看起来是绕圆旋转
        //     var cosy = Math.cos(angleY),
        //         siny = Math.sin(angleY),
        //     // 把 z方向影响算进来
        //         x1 = ball.xpos * cosy - ball.zpos * siny,
        //         z1 = ball.zpos * cosy + ball.xpos * siny;
        //     ball.xpos = x1;
        //     ball.zpos = z1;

        //     // z坐标扁平化，并赋给小球影响
        //     var scale = focalLength / (focalLength + ball.zpos);
        //     ball.x = vpx + ball.xpos * scale;
        //     ball.y = vpy + ball.ypos * scale;
        //     ball.width = ballR*2*scale;
        // }

        function rotateY(item,angleY){
            var cos = Math.cos(angleY),
                sin = Math.sin(angleY),
                x1 = item.x * cos - item.z * sin,
                z1 = item.z * cos + item.x * sin;
            item.x = x1;
            item.z = z1;
        }

		function Point(x,y,z,radius,rgb){
			// 点在字体中的坐标
			this.dx=x;
			this.dy=y;
			this.dz=z;
			// 点当前的坐标
			this.x=Math.floor(Math.random()*canvas.width);
			this.y=Math.floor(Math.random()*canvas.height);
			this.z=Math.floor(Math.random()*zRadius*2-zRadius);
			// 点最终飞离的坐标
			this.fx=Math.floor(Math.random()*canvas.width);
			this.fy=Math.floor(Math.random()*canvas.height);
			this.fz=Math.floor(Math.random()*zRadius*2-zRadius);
			this.radius=radius;
            this.rgb=rgb;
		}
		Point.prototype.paint=function(){
            ctx.save();
            ctx.beginPath();
            var scale = zRadius / (zRadius + this.z);
            ctx.arc(canvas.width / 2 + (this.x - canvas.width / 2) * scale, canvas.height / 2 + (this.y - canvas.height / 2) * scale, this.radius * scale, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba('+this.rgb.r+','+this.rgb.g+','+this.rgb.b+',' + scale*0.5 + ')';
            ctx.fill();
            ctx.restore();
		};

		function init(){
			canvas.width=window.innerWidth;
			canvas.height=window.innerHeight;
			points=getImgData(text);
			animate();
		}

		init();

	}())
</script>
</body>
</html>