<!doctype html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <style>
        html,body {
            padding: 0;
            margin: 0;
        }

        canvas {
			background-color:rgba(0,0,0,0);
            -webkit-transition: background-color 1s ease-in-out;
            -o-transition: background-color 1s ease-in-out;
            transition: background-color 1s ease-in-out;
        }
    </style>
    <title>canvas粒子特效</title>
</head>
<body>
<div>
    <canvas id='canvas' width="1200" height="800">浏览器不支持canvas</canvas>
</div>
<script>
	(function(){
		var RequestAnimFrame=window.requestAnimationFrame 
            || window.webkitRequestAnimationFrame 
            || window.mozRequestAnimationFrame 
            || window.oRequestAnimationFrame 
            || window.msRequestAnimationFrame 
            || function(callback) {return window.setTimeout(callback, 16); };

        var CVS=(function(){
            var canvas=document.getElementById('canvas'),
                ctx=canvas.getContext('2d');
                vpx=canvas.width/2,
                vpy=canvas.height/2;

            canvas.width=window.innerWidth;
            canvas.height=window.innerHeight;
            vpx=canvas.width/2;
            vpy=canvas.height/2;
            ctx.translate(this.vpx,this.vpy);//坐标原点重置为中间

            return {
                canvas:canvas,
                ctx:ctx,
                vpx: vpx,
                vpy: vpy,
                clearRect:function(){
                    ctx.clearRect(-vpx, -vpy, canvas.width, canvas.height);
                }
            }
        }());

        function PointEffect(opt){
            var options={
                zRadius:200,
                zPos:0,
                txts:['粒子特效']
            };
            for(var prop in opt){
                opt[prop]&&(options[prop]=opt[prop]);
            }

            this.zRadius=options.zRadius;
            this.zPos=options.zPos;
            this.txts=options.txts;
            this.poionts=[];
        }
        PointEffect.prototype={
            init:function(){
                this.animate(0);
            },
            drawText:function(txt){
                CVS.ctx.save()
                CVS.ctx.font = "200px Microsoft YaHei bold";
                // 设置渐变
                var gradient=CVS.ctx.createLinearGradient(-CVS.vpx,-CVS.vpy,CVS.canvas.width,0);
                gradient.addColorStop(0,'#00ff00');
                gradient.addColorStop(0.3,'purple');
                gradient.addColorStop(0.5,'red');
                gradient.addColorStop(0.6,'orange');
                gradient.addColorStop(1,'yellow');

                CVS.ctx.fillStyle=gradient;
                CVS.ctx.textAlign = "center";
                CVS.ctx.textBaseline = "middle";
                CVS.ctx.fillText(txt, 0,0);
                CVS.ctx.restore();
            },
            getImgData:function(txt){
                var imgData = CVS.ctx.getImageData(0, 0, CVS.canvas.width, CVS.canvas.height);
                CVS.clearRect();
                this.points = [];
                for (var x = 0; x < imgData.width; x += 6) {
                    for (var y = 0; y < imgData.height; y += 6) {
                        var i = (y * imgData.width + x) * 4;
                        if (imgData.data[i] >= 20) {
                            var point = new Point(this.zRadius,this.zPos,x, y, 0, 3,{r:imgData.data[i],g:imgData.data[i+1],b:imgData.data[i+2]});
                            this.points.push(point);
                        }
                    }
                }
            },
            animate:function(index){
                var isStop=true,
                    stage=0,
                    zoom=0.05,
                    startTime=new Date(),
                    self=this;

                this.drawText(this.txts[index]);
                this.getImgData(this.txts[index]);

                (function(){
                    isStop=true;
                    self.points.forEach(function(item,i){
                        switch(stage){
                            case 0:
                                if(Math.abs(item.x-item.dx)<0.1&&Math.abs(item.y-item.dy)<0.1&&Math.abs(item.z-item.dz)<0.1){
                                    item.x=item.dx;
                                    item.y=item.dy;
                                    item.z=item.dz;
                                } else {
                                    item.x=item.x+(item.dx-item.x)*zoom;
                                    item.y=item.y+(item.dy-item.y)*zoom;
                                    item.z=item.z+(item.dz-item.z)*zoom;
                                    isStop=false;
                                }
                                break;
                            case 1:
                                if(Math.abs(item.x-item.fx)<0.1&&Math.abs(item.y-item.fy)<0.1&&Math.abs(item.z-item.fz)<0.1){
                                    item.x=item.fx;
                                    item.y=item.fy;
                                    item.z=item.fz;
                                } else {
                                    item.x=item.x+(item.fx-item.x)*zoom;
                                    item.y=item.y+(item.fy-item.y)*zoom;
                                    item.z=item.z+(item.fz-item.z)*zoom;
                                    isStop=false;
                                }
                                break;
                      
                            default:break;
                        }
                    });
                    self.points.sort(function(a,b){
                        return b.z-a.z;
                    });

                    CVS.clearRect();
                    self.points.forEach(function(item,i){item.paint(); });

                    if(isStop&&stage==1){
                        // CVS.canvas.style.backgroundColor='rgba(0,0,0,0)';
                        CVS.clearRect();
                        CVS.canvas.style.backgroundColor='rgba(0,0,0,1)';
                        self.animate(++index%self.txts.length);
                        return false;
                    }
                    if(isStop&&stage!=1){
                        stage++;
                        if(stage==1){
                            CVS.canvas.style.backgroundColor='rgba(0,0,0,0.7)';
                        }
                        // if(stage==2){
                        //     startTime=new Date();
                        // }
                    }
                    RequestAnimFrame(arguments.callee);
                }());
            },
        };

		function Point(zRadius,zPos,x,y,z,radius,rgb){
			// 点在字体中的坐标
			this.dx=x-CVS.vpx;
			this.dy=y-CVS.vpy;
			this.dz=z;
			// 点当前的坐标
			this.x=Math.floor(Math.random()*CVS.canvas.width-CVS.vpx);
			this.y=Math.floor(Math.random()*CVS.canvas.height-CVS.vpy);
			this.z=Math.floor(Math.random()*zRadius*2-zRadius);
			// 点最终飞离的坐标
			this.fx=Math.floor(Math.random()*CVS.canvas.width-CVS.vpx);
			this.fy=Math.floor(Math.random()*CVS.canvas.height-CVS.vpy);
			this.fz=Math.floor(Math.random()*zRadius*2-zRadius);
			this.radius=radius;
            this.rgb=rgb;
            this.zRadius=zRadius;
            this.zPos=zPos;
		}
		Point.prototype.paint=function(){
            var scale = Math.abs(this.zRadius/(this.zRadius-this.z+this.zPos));
            CVS.ctx.save();
            CVS.ctx.beginPath();
            CVS.ctx.arc(this.x*scale,this.y*scale, this.radius * scale, 0, 2 * Math.PI);
            CVS.ctx.fillStyle = 'rgba('+this.rgb.r+','+this.rgb.g+','+this.rgb.b+',' + scale*0.5 + ')';
            CVS.ctx.fill();
            CVS.ctx.restore();
		};

        var effect=new PointEffect({txts:['粒子特效','jeff.zhong','Hello,Canvas']});
        effect.init();
	}());
</script>
</body>
</html>